# -*- coding: utf-8 -*-
"""heirarchical-emotion-classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VO8JXsJht3BmZUuiVXWs9-q6M55HIjAm
"""

# # # Unzipping the uploaded file
!unzip -q /content/EmotionData.zip -d /content/

# # # Check contents of the unzipped folder
!ls /content/EmotionData

"""## Importing Dependencies"""

# Import necessary libraries

import os
import matplotlib.pyplot as plt
import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from sklearn.metrics import classification_report, confusion_matrix

"""## The porject is based on 2 levels

- level 1 : To preprocess and train catagories (e.g Negative, Neutral and Positive
- level 2 : Further classify the emotions into the specific catagories

## Data Preprocessing of Level1 Catagories

 - Negative
 - Neutral
 - Positive
"""

# Define base directory path
base_dir = '/content/EmotionData/'

# Data augmentation and preprocessing for training
train_datagen = ImageDataGenerator(rescale=1./255, validation_split=0.2)

# Load training and validation datasets
train_generator = train_datagen.flow_from_directory(
    base_dir,
    target_size=(128, 128),
    batch_size=32,
    class_mode='categorical',
    subset='training'  # Training set
)

validation_generator = train_datagen.flow_from_directory(
    base_dir,
    target_size=(128, 128),
    batch_size=32,
    class_mode='categorical',
    subset='validation'  # Validation set
)

"""## Build & Train the Model for Catagories"""

# Define the CNN model for Level 1 classification
model_level1 = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(128, 128, 3)),
    MaxPooling2D(pool_size=(2, 2)),
    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D(pool_size=(2, 2)),
    Flatten(),
    Dense(128, activation='relu'),
    Dense(3, activation='softmax')
])

# Compile the model
model_level1.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Train the model
history_level1 = model_level1.fit(
    train_generator,
    validation_data=validation_generator,
    epochs=5
)

"""## Evaluate the Model

"""

# Evaluate model performance
val_loss, val_acc = model_level1.evaluate(validation_generator)
print(f'Validation Accuracy: {val_acc * 100:.2f}%')

# Display confusion matrix and classification report
Y_pred = model_level1.predict(validation_generator)
Y_pred

y_pred = np.argmax(Y_pred, axis=1)
print('Confusion Matrix')
print(confusion_matrix(validation_generator.classes, y_pred))

print('Classification Report')
target_names = ['Negative', 'Neutral', 'Positive']
print(classification_report(validation_generator.classes, y_pred, target_names=target_names))

"""## Data Preprocessing for Level 2

 - Subcatagories of Level1
"""

# Define paths to Level 2 Positive dataset
positive_dir = '/content/EmotionData/Positive/'

train_datagen_positive = ImageDataGenerator(rescale=1./255, validation_split=0.2)

train_generator_positive = train_datagen_positive.flow_from_directory(
    positive_dir,
    target_size=(128, 128),
    batch_size=32,
    class_mode='categorical',
    subset='training'
)

validation_generator_positive = train_datagen_positive.flow_from_directory(
    positive_dir,
    target_size=(128, 128),
    batch_size=32,
    class_mode='categorical',
    subset='validation'
)

# Define paths to Level 2 Negative dataset
negative_dir = '/content/EmotionData/Negative/'

train_datagen_negative = ImageDataGenerator(rescale=1./255, validation_split=0.2)

train_generator_negative = train_datagen_negative.flow_from_directory(
    negative_dir,
    target_size=(128, 128),
    batch_size=32,
    class_mode='categorical',
    subset='training'
)

validation_generator_negative = train_datagen_negative.flow_from_directory(
    negative_dir,
    target_size=(128, 128),
    batch_size=32,
    class_mode='categorical',
    subset='validation'
)

"""## Build and Train the Level 2 Models

"""

# Define the CNN model for Positive Emotion Classification (Level 2)
model_positive = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(128, 128, 3)),
    MaxPooling2D(pool_size=(2, 2)),
    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D(pool_size=(2, 2)),
    Flatten(),
    Dense(128, activation='relu'),
    Dense(2, activation='softmax')
])

# Compile the model
model_positive.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Train the model
history_positive = model_positive.fit(
    train_generator_positive,
    validation_data=validation_generator_positive,
    epochs=5
)

# Define the CNN model for Negative Emotion Classification (Level 2)
model_negative = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(128, 128, 3)),
    MaxPooling2D(pool_size=(2, 2)),
    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D(pool_size=(2, 2)),
    Flatten(),
    Dense(128, activation='relu'),
    Dense(4, activation='softmax')
])

# Compile the model
model_negative.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Train the model
history_negative = model_negative.fit(
    train_generator_negative,
    validation_data=validation_generator_negative,
    epochs=5
)

def hierarchical_emotion_classification(image):
    # Step 1: Level 1 classification
    level1_pred = model_level1.predict(image)
    level1_class = np.argmax(level1_pred)

    if level1_class == 2:  # Positive
        # Step 2: Classify into Happy or Surprised
        level2_pred = model_positive.predict(image)
        emotion = 'Happy' if np.argmax(level2_pred) == 0 else 'Surprised'

    elif level1_class == 0:  # Negative
        # Step 2: Classify into Angry, Sad, Disgusted, Fearful
        level2_pred = model_negative.predict(image)
        emotion_labels = ['Angry', 'Sad', 'Disgusted', 'Fearful']
        emotion = emotion_labels[np.argmax(level2_pred)]

    else:
        # Neutral emotion
        emotion = 'Neutral'

    return emotion

from tensorflow.keras.preprocessing import image
import numpy as np

# Load and preprocess the test image
def load_image(img_path):
    # Load the image with target size
    img = image.load_img(img_path, target_size=(128, 128))
    # Convert the image to an array
    img_array = image.img_to_array(img)
    # Reshape and normalize the image array
    img_array = np.expand_dims(img_array, axis=0)  # Shape becomes (1, 128, 128, 3)
    img_array /= 255.  # Rescale pixel values
    return img_array

# List of test image paths
test_images = ['/content/EmotionData/Negative/Disgusted/im10.png', '/content/EmotionData/Negative/Fearful/im1000.png','/content/EmotionData/Negative/Sad/im1001.png','/content/EmotionData/Negative/Angry/im1002.png']

# Iterate over the test images
for img_path in test_images:
    # Load and preprocess the image
    img = load_image(img_path)

    # Predict emotion
    emotion = hierarchical_emotion_classification(img)

    # Print the result
    print(f'Image: {img_path} | Predicted Emotion: {emotion}')

# After training the model for positive emotions (happy, surprised)
model_positive.save('positive_emotion_classifier.h5')
# After training the model for negative emotions (sad, angry, fearful, etc.)
model_negative.save('negative_emotion_classifier.h5')
#
model_level1.save('level1_emotion_classifier.h5')

!pip install flask-ngrok

import tensorflow as tf
from flask import Flask, request, jsonify
from tensorflow.keras.preprocessing import image
import numpy as np
from PIL import Image

# Load the saved models (adjust paths as needed)
model_level1 = tf.keras.models.load_model('level1_emotion_classifier.h5')
model_positive = tf.keras.models.load_model('positive_emotion_classifier.h5')
model_negative = tf.keras.models.load_model('negative_emotion_classifier.h5')

# Initialize Flask app
app = Flask(__name__)

# Preprocessing function for images
def preprocess_image(img):
    img = img.resize((224, 224))  # Resize to the input size expected by your model
    img = np.array(img)
    img = img.astype('float32') / 255.0  # Normalize image
    img = np.expand_dims(img, axis=0)  # Add batch dimension
    return img

# Hierarchical emotion classification
def classify_emotion(image):
    # Step 1: Use level 1 classifier to distinguish between positive and negative
    level1_prediction = model_level1.predict(image)
    level1_label = np.argmax(level1_prediction)  # 0 for negative, 1 for positive

    if level1_label == 1:
        # Positive emotions (happy, surprised)
        prediction = model_positive.predict(image)
        labels = ['happy', 'surprised']
    else:
        # Negative emotions (sad, angry, fearful)
        prediction = model_negative.predict(image)
        labels = ['sad', 'angry', 'fearful']

    predicted_label = labels[np.argmax(prediction)]
    return predicted_label

# Endpoint to classify emotion
@app.route('/predict', methods=['POST'])
def predict():
    if 'file' not in request.files:
        return jsonify({'error': 'No file provided'}), 400

    file = request.files['file']

    if file.filename == '':
        return jsonify({'error': 'No file selected'}), 400

    try:
        img = Image.open(file)
        processed_image = preprocess_image(img)

        # Classify emotion hierarchically
        predicted_emotion = classify_emotion(processed_image)

        return jsonify({'emotion': predicted_emotion})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# Main function to run the Flask app
if __name__ == '__main__':
    app.run(debug=True)

